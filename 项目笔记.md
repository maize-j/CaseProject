#准备工作
1. 划分目录结构（主要划分src中的目录结构）
	1. assets（静态资源）
		1. css（存放css文件）
		2. img（存放图片资源）
	2. components（公共组件）
		1. common（完全公共的组件，在其他的项目中也可以使用）
		2. content（存放和当前业务相关的公共组件）
	3. views（存放和当前项目相关的一些视图组件，可根据项目需求再一次划分）
	4. router（存放和路由相关的文件夹）
	5. store（存放vuex相关的文件）
	6. network（和网络请求相关的所有文件存放位置）
	7. common（存放公共的js文件）
		1. const.js（公共常量）
		2. utils.js（公共的工具方法）
		3. mixin.js（公共的混入方法）
	8. 在项目的根目录下创建vue.config.js（webpack的配置文件）
	9. 在项目的根目录下创建.editorconfig（主要用于多人开发项目时，统一编码风格）
2. 引入两个css文件
	1. base.css（项目所需要的简单公共布局）
	2. normalize.css（在github上下载的目前引用较多的css样式，https://github.com/necolas/normalize.css）
3. 配置vue.config.js文件和.editorconfig文件
	
4. 首页开发
5. 
6. 父子组件的通信问题
	1. 当父组件同时引用了两个子组件，而这两个子组件想要进行通信时，最原始的解决办法是在父组件中获取到两个子组件再解决。
	2. 但是当子组件中也引用了其他的子组件，要想在父组件中进行处理，就需要层层获取，这种处理方式显得笨拙且容易出错
	3. 我们可以用事件总线的方式，在main.js中的Vue的原型中创建一个事件总线$bus，在子组件中发射事件直接发射到事件总线中，其他的子组件要与该子组件通信时，直接从事件总线中拿到事件并作出处理。
	

7. 对于监听首页的商品图片，refresh方法操作过于频繁的问题
	1. 可以使用js的防抖（debounce）和节流（throttle）函数
	2. 防抖函数的作用原理
		1. 设置一个时间限定，将原本要进行的refresh方法传入到debounce函数中，将会生成一个新的函数
		2. 在新的函数生成后，不会频繁的调用，而是根据时间限定来决定，如果第二次执行到来的很快，在时间限定之内，将会取消上一次执行。如果下一次操作在时间限定后还没到达，那么将执行本次操作（详细见Home页面的methods中的debounce函数和mounted中的调用）
8. 